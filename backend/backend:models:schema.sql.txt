-- Usuarios
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(12) UNIQUE NOT NULL,
    time_balance_ms BIGINT DEFAULT 259200000, -- 72h en ms
    last_updated TIMESTAMP DEFAULT NOW(),
    is_frozen BOOLEAN DEFAULT FALSE,
    frozen_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Amistades (única por par, con recompensa)
CREATE TABLE friendships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id_1 UUID REFERENCES users(id),
    user_id_2 UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    reward_tier INTEGER CHECK (reward_tier IN (1, 2, 3)), -- 1=24h, 2=12h, 3=4h
    UNIQUE(user_id_1, user_id_2)
);

-- Acciones diarias (reset a medianoche UTC)
CREATE TABLE daily_actions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    date DATE DEFAULT CURRENT_DATE,
    friends_made INTEGER DEFAULT 0,
    gifts_sent INTEGER DEFAULT 0,
    tokens_used INTEGER DEFAULT 0,
    UNIQUE(user_id, date)
);

-- Transferencias de tiempo (regalos)
CREATE TABLE time_transfers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user UUID REFERENCES users(id),
    to_user UUID REFERENCES users(id),
    amount_ms BIGINT NOT NULL,
    type VARCHAR(20) CHECK (type IN ('gift', 'token', 'friend_reward')),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Tokens enviados (5 por día)
CREATE TABLE tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id UUID REFERENCES users(id),
    receiver_id UUID REFERENCES users(id),
    message_type INTEGER CHECK (message_type IN (1,2,3,4,5)),
    affects_time BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Función para calcular tiempo actual
CREATE OR REPLACE FUNCTION get_current_time_balance(user_uuid UUID)
RETURNS BIGINT AS $$
DECLARE
    user_record RECORD;
    elapsed_ms BIGINT;
BEGIN
    SELECT time_balance_ms, last_updated, is_frozen 
    INTO user_record 
    FROM users 
    WHERE id = user_uuid;
    
    IF user_record.is_frozen THEN
        RETURN 0;
    END IF;
    
    elapsed_ms := EXTRACT(EPOCH FROM (NOW() - user_record.last_updated)) * 1000;
    RETURN GREATEST(0, user_record.time_balance_ms - elapsed_ms);
END;
$$ LANGUAGE plpgsql;